<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Castle.MicroKernel</name>
    </assembly>
    <members>
        <member name="T:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator">
            <summary>
            Abstract implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>.
            The implementors must only override the InternalCreate and 
            InternalDestroy methods in order to perform their creation and
            destruction logic.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IComponentActivator">
            <summary>
            Implements the instance creation logic. The default
            implementation should rely on an ordinary call to 
            Activator.CreateInstance(). 
            </summary>
            <remarks>
            This interface is provided in order to allow custom components
            to be created using a different logic, such as using a specific factory
            or builder.
            <br/>
            The constructor for implementation have the following signature:
            <code>
            ComponentModel model, IKernel kernel, 
            ComponentInstanceDelegate onCreation, 
            ComponentInstanceDelegate onDestruction
            </code>
            The Activator should raise the events onCreation and onDestruction
            in order to correctly implement the contract. Usually the best
            way of creating a custom activator is by extending the existing ones.
            
            <seealso cref="T:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator"/>
            <seealso cref="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator"/>
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.IComponentActivator.Create(Castle.MicroKernel.CreationContext)">
            <summary>
            Should return a new component instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IComponentActivator.Destroy(System.Object)">
            <summary>
            Should perform all necessary work to dispose the instance
            and/or any resource related to it.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.ComponentActivator.AbstractComponentActivator.#ctor(Castle.Core.ComponentModel,Castle.MicroKernel.IKernel,Castle.MicroKernel.ComponentInstanceDelegate,Castle.MicroKernel.ComponentInstanceDelegate)">
            <summary>
            Constructs an AbstractComponentActivator
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.ComponentActivatorException">
            <summary>
            Summary description for ComponentActivatorException.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentActivator.DefaultComponentActivator">
            <summary>
            Standard implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>.
            Handles the selection of the best constructor, fills the
            writable properties the component exposes, run the commission 
            and decommission lifecycles, etc.
            </summary>
            <remarks>
            Custom implementors can just override the <c>CreateInstance</c> method.
            Please note however that the activator is responsible for the proxy creation
            when needed.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.CreationContext.TrackDependency(System.Reflection.MemberInfo,Castle.Core.DependencyModel)">
            <summary>
            Track dependencies and guards against circular dependencies.
            </summary>
            <returns>A dependency key that can be used to remove the dependency if it was resolved correctly.</returns>
        </member>
        <member name="M:Castle.MicroKernel.CreationContext.RemoveDependencyTracking(System.Object)">
            <summary>
            Removes a dependency that was resolved successfully.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentNotFoundException">
            <summary>
            Summary description for ComponentNotFoundException.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentRegistrationException">
            <summary>
            Summary description for ComponentRegistrationException.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.KernelException">
            <summary>
            Summary description for KernelException.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Facilities.FacilityException">
            <summary>
            Base exception to be used by facilities.
            </summary>
        </member>
        <member name="T:Castle.Facilities.EventWiring.EventWiringFacility">
            <summary>
            Facility to allow components to dynamically subscribe to events offered by 
            other components. We call the component that offers events publishers and 
            the components that uses them, subscribers.
            </summary>
            <remarks>
            A component that wish to subscribe to an event must use the external configuration
            adding a node <c>subscribes</c>. This node can have multiple entries using the 
            <c>subscribe-to</c> node.
            <para>TODO: Add a configuration sample to this documentation</para>
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Facilities.AbstractFacility">
            <summary>
            Base class for facilities. 
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IFacility">
            <summary>
            Unit of extension. A facility should use 
            the extension points offered by the kernel
            to augment its functionality.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IFacility.Init(Castle.MicroKernel.IKernel,Castle.Core.Configuration.IConfiguration)">
            <summary>
            
            </summary>
            <param name="kernel"></param>
            <param name="facilityConfig"></param>
        </member>
        <member name="M:Castle.MicroKernel.IFacility.Terminate">
            <summary>
            
            </summary>
        </member>
        <member name="F:Castle.Facilities.EventWiring.EventWiringFacility.model2SubcribeNode">
            <summary>
            Maps a <see cref="T:Castle.Core.ComponentModel"/> to a <see cref="T:Castle.Core.Configuration.IConfiguration"/> that represents 
            the <c>subscribes</c> node
            </summary>
        </member>
        <member name="F:Castle.Facilities.EventWiring.EventWiringFacility.publishers">
            <summary>
            Maps the <see cref="T:Castle.Core.ComponentModel"/> of a subscriber to a list of publishers. The M
            </summary>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.#ctor">
            <summary>
            Constructs the facility
            </summary>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.ExtractAndRegisterEventInformation(Castle.Core.ComponentModel)">
            <summary>
            Checks whether the component model has, on its configuration, 
            a <c>subscribes</c> node. If so adds it to a hashtable associated
            with the model, and updates the publisher information adding it 
            as a subscriber
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.StartAndWireSubscribers(Castle.Core.ComponentModel,System.Object)">
            <summary>
            Checks if the component we're dealing is a publisher. If it is, 
            iterates the subscribers starting them.
            </summary>
            <param name="model"></param>
            <param name="publisher"></param>
        </member>
        <member name="M:Castle.Facilities.EventWiring.EventWiringFacility.WireEventsIfNeeded(Castle.Core.ComponentModel,System.Object)">
            <summary>
            
            </summary>
            <param name="model"></param>
            <param name="instance"></param>
        </member>
        <member name="T:Castle.Facilities.EventWiring.WireInfo">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.Facilities.FactorySupport.FactoryActivator">
            <summary>
            
            </summary>
        </member>
        <member name="F:Castle.Facilities.Remoting.RemotingFacility.baseUri">
            <summary>
            Used for client side (Expand explanation)
            </summary>
        </member>
        <member name="F:Castle.Facilities.Remoting.RemotingFacility.localRegistry">
            <summary>
            Used for server side. 
            Holds the local registry
            </summary>
        </member>
        <member name="F:Castle.Facilities.Remoting.RemotingFacility.remoteRegistry">
            <summary>
            Used for client side. 
            Holds a remote proxy to the server registry
            </summary>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemotingFacility.#ctor">
            <summary>
            Constructs a RemotingFacility
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction">
            <summary>
            Implementors must inspect the component for 
            a given information or parameter.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Usually the implementation will look in the configuration property 
            of the model or the service interface, or the implementation looking for
            something.
            </summary>
            <param name="kernel">The kernel instance</param>
            <param name="model">The component model</param>
        </member>
        <member name="M:Castle.Facilities.Remoting.RemotingInspector.ResetDependencies(Castle.Core.ComponentModel)">
            <summary>
            Client components are not created by the container
            so there's no point collecting constructor dependencies
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacility.CheckWaitingList">
            <summary>
            For each new component registered,
            some components in the WaitingDependency
            state may have became valid, so we check them
            </summary>
        </member>
        <member name="M:Castle.Facilities.Startable.StartableFacility.Start(System.String)">
            <summary>
            Request the component instance
            </summary>
            <param name="key"></param>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.ILifecycleConcern">
            <summary>
            Summary description for ILifecycleConcern.
            </summary>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.FactoryInterceptor">
            <summary>
            Summary description for FactoryInterceptor.
            </summary>
        </member>
        <member name="T:Castle.Facilities.TypedFactory.TypedFactoryFacility">
            <summary>
            Summary description for TypedFactoryFacility.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.AbstractHandler">
            <summary>
            Implements the basis of <see cref="T:Castle.MicroKernel.IHandler"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IHandler">
            <summary>
            Contract for the IHandler, which manages an
            component state and coordinates its creation 
            and destruction (dispatching to activators, lifestyle managers)
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Init(Castle.MicroKernel.IKernel)">
            <summary>
            Initializes the handler with a reference to the
            kernel.
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Resolve(Castle.MicroKernel.CreationContext)">
            <summary>
            Implementors should return a valid instance 
            for the component the handler is responsible.
            It should throw an exception in the case the component
            can't be created for some reason
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IHandler.Release(System.Object)">
            <summary>
            Implementors should dispose the component instance
            </summary>
            <param name="instance"></param>
        </member>
        <member name="P:Castle.MicroKernel.IHandler.CurrentState">
            <summary>
            Gets the state of the handler
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IHandler.ComponentModel">
            <summary>
            Gets the model of the component being 
            managed by this handler.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.IExposeDependencyInfo">
            <summary>
            Might be implemented by a handler 
            so it can expose access to dependency information 
            which is used to construct meaningful error messages
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.IExposeDependencyInfo.ObtainDependencyDetails(System.Collections.IList)">
            <summary>
            Returns human readable list of dependencies 
            this handler is waiting for.
            <param name="dependenciesChecked">list of the dependecies that was already checked, used to avoid cycles.</param>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.DependencySatisfied(Castle.MicroKernel.IHandler,System.Boolean@)">
            <summary>
            Invoked by the kernel
            when one of registered dependencies were satisfied by 
            new components registered.
            </summary>
            <param name="handler"></param>
        </member>
        <member name="M:Castle.MicroKernel.Handlers.AbstractHandler.ObtainDependencyDetails(System.Collections.IList)">
            <summary>
            Returns human readable list of dependencies 
            this handler is waiting for.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.DefaultGenericHandler">
            <summary>
            Summary description for DefaultGenericHandler.
            </summary>
            <remarks>
            TODO: Consider refactoring AbstractHandler moving lifestylemanager
            creation to DefaultHandler
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.DefaultHandler">
            <summary>
            Summary description for DefaultHandler.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.DefaultHandlerFactory">
            <summary>
            Summary description for DefaultHandlerFactory.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IHandlerFactory">
            <summary>
            Extension point to allow the developer
            to use his implementation of <see cref="T:Castle.MicroKernel.IHandler"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Handlers.HandlerException">
            <summary>
            Summary description for HandlerException.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.HandlerState">
            <summary>
            Possible states for a IHandler instance
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.HandlerState.Valid">
            <summary>
            The component can be requested
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.HandlerState.WaitingDependency">
            <summary>
            The component can not be requested 
            as it still depending on a external 
            dependency not yet available
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.DisposalConcern">
            <summary>
            Summary description for DisposalConcern.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.InitializationConcern">
            <summary>
            Summary description for InitializationConcern.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.LifecycleConcerns.SupportInitializeConcern">
            <summary>
            Summary description for SupportInitializeConcern.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.Pool.IPool">
            <summary>
            Pool implementation contract. 
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.Pool.IPool.Request(Castle.MicroKernel.CreationContext)">
            <summary>
            Implementors should return a component instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.Pool.IPool.Release(System.Object)">
            <summary>
            Implementors should release the instance or put it
            on the pool
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.Pool.DefaultPool.InitPool">
            <summary>
            Initializes the pool to a initial size by requesting
            n components and then releasing them.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.AbstractLifestyleManager">
            <summary>
            Summary description for AbstractLifestyleManager.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ILifestyleManager">
            <summary>
            The <c>ILifestyleManager</c> implements 
            a strategy for a given lifestyle, like singleton, perthread
            and transient.
            </summary>
            <remarks>
            The responsability of <c>ILifestyleManager</c>
            is only the management of lifestyle. It should rely on
            <see cref="T:Castle.MicroKernel.IComponentActivator"/> to obtain a new component instance
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Init(Castle.MicroKernel.IComponentActivator,Castle.MicroKernel.IKernel)">
            <summary>
            Initializes the <c>ILifestyleManager</c> with the 
            <see cref="T:Castle.MicroKernel.IComponentActivator"/>
            </summary>
            <param name="componentActivator"></param>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Resolve(Castle.MicroKernel.CreationContext)">
            <summary>
            Implementors should return the component instance based 
            on the lifestyle semantic.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ILifestyleManager.Release(System.Object)">
            <summary>
            Implementors should release the component instance based
            on the lifestyle semantic, for example, singleton components
            should not be released on a call for release, instead they should
            release them when disposed is invoked.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.PerThreadLifestyleManager">
            <summary>
            Summary description for PerThreadLifestyleManager.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.Lifestyle.PerThreadLifestyleManager.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.PoolableLifestyleManager">
            <summary>
            Implements a Poolable Lifestyle Manager. 
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.SingletonLifestyleManager">
            <summary>
            Summary description for SingletonLifestyleManager.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Lifestyle.TransientLifestyleManager">
            <summary>
            Summary description for TransientLifestyleManager.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector">
            <summary>
            Uses the ConfigurationStore registered in the kernel to obtain
            an <see cref="T:Castle.Core.Configuration.IConfiguration"/> associated with the component.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Queries the kernel's ConfigurationStore for a configuration
            associated with the component name.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector">
            <summary>
            Check for a node 'parameters' within the component 
            configuration. For each child it, a ParameterModel is created
            and added to ComponentModel's Parameters collection
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.ConfigurationParametersInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Inspect the configuration associated with the component
            and populates the parameter model collection accordingly
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.ConstructorDependenciesModelInspector">
            <summary>
            This implementation of <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction"/>
            collects all available constructors and populates them in the model
            as candidates. The Kernel will pick up one of the candidates
            according to a heuristic.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ExtendedPropertiesConstants">
            <summary>
            Only to hold internal constants and get rid of 
            magic numbers and hardcode names.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.GenericInspector">
            <summary>
            
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.InterceptorInspector">
            <summary>
            Inspect the component for <c>InterceptorAttribute</c> and
            the configuration for the interceptors node
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector">
            <summary>
            Inspects the type looking for interfaces that constitutes
            lifecycle interfaces, defined in the Castle.Model namespace.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifecycleModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Checks if the type implements <see cref="T:Castle.Core.IInitializable"/> and or
            <see cref="T:System.IDisposable"/> interfaces.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector">
            <summary>
            Inspects the component configuration and the type looking for a
            definition of lifestyle type. The configuration preceeds whatever
            is defined in the component.
            </summary>
            <remarks>
            This inspector is not guarantee to always set up an lifestyle type. 
            If nothing could be found it wont touch the model. In this case is up to
            the kernel to estabish a default lifestyle for components.
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Seaches for the lifestyle in the configuration and, if unsuccessful
            look for the lifestyle attribute in the implementation type.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ReadLifestyleFromConfiguration(Castle.Core.ComponentModel)">
            <summary>
            Reads the attribute "lifestyle" associated with the 
            component configuration and tries to convert to <see cref="T:Castle.Core.LifestyleType"/> 
            enum type. 
            </summary>
            <exception cref="T:System.Configuration.ConfigurationException">
            If the conversion fails
            </exception>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.LifestyleModelInspector.ReadLifestyleFromType(Castle.Core.ComponentModel)">
            <summary>
            Check if the type expose one of the lifestyle attributes
            defined in Castle.Model namespace.
            </summary>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector">
            <summary>
            Base for inspectors that want configuration associated with methods.
            For each child a <see cref="T:Castle.Core.MethodMetaModel"/> is created
            and added to ComponentModel's methods collection
            </summary>
            <remarks>
            Implementors should override the <see cref="M:Castle.MicroKernel.ModelBuilder.Inspectors.MethodMetaInspector.ObtainNodeName"/> return
            the name of the node to be inspected. For example:
            <code>
            <pre>
              <transactions>
                <method name="Save" transaction="requires"/>
              </transactions>
            </pre>
            </code>
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector">
            <summary>
            This implementation of <see cref="T:Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction"/>
            collects all potential writable puplic properties exposed by the component 
            implementation and populates the model with them.
            The Kernel might be able to set some of these properties when the component 
            is requested.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ModelBuilder.Inspectors.PropertiesDependenciesModelInspector.ProcessModel(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel)">
            <summary>
            Adds the properties as optional dependencies of this component.
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
        </member>
        <member name="T:Castle.MicroKernel.ModelBuilder.DefaultComponentModelBuilder">
            <summary>
            Summary description for DefaultComponentModelBuilder.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IComponentModelBuilder">
            <summary>
            Implementors must construct a populated
            instance of ComponentModel by inspecting the component
            and|or the configuration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.BuildModel(System.String,System.Type,System.Type,System.Collections.IDictionary)">
            <summary>
            Constructs a new ComponentModel by invoking
            the registered contributors.
            </summary>
            <param name="key"></param>
            <param name="service"></param>
            <param name="classType"></param>
            <param name="extendedProperties"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.AddContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
            "To give or supply in common with others; give to a 
            common fund or for a common purpose". The contributor
            should inspect the component, or even the configuration
            associated with the component, to add or change information
            in the model that can be used later.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IComponentModelBuilder.RemoveContributor(Castle.MicroKernel.ModelBuilder.IContributeComponentModelConstruction)">
            <summary>
            Removes the specified contributor
            </summary>
            <param name="contributor"></param>
        </member>
        <member name="T:Castle.MicroKernel.IProxyFactory">
            <summary>
            Defines the contract used by the kernel 
            to obtain proxies for components. The implementor
            must return a proxied instance that dispatch 
            the invocation to the registered interceptors in the model
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IProxyFactory.Create(Castle.MicroKernel.IKernel,Castle.Core.ComponentModel,System.Object[])">
            <summary>
            Implementors must create a proxy based on 
            the information exposed by ComponentModel
            </summary>
            <param name="kernel"></param>
            <param name="model"></param>
            <param name="constructorArguments"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.Proxy.NotSupportedProxyFactory">
            <summary>
            This is a placeholder implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>.
            </summary>
            <remarks>
            The decision to supply no implementation for <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            is supported by the fact that the MicroKernel should be a thin
            assembly with the minimal set of features, although extensible.
            Providing the support for this interface would obligate 
            the user to import another assembly, even if the large majority of
            simple cases, no use use of interceptors will take place.
            If you want to use however, see the Windsor container.
            </remarks>
        </member>
        <member name="T:Castle.MicroKernel.Releasers.AllComponentsReleasePolicy">
            <summary>
            Summary description for AllComponentsReleasePolicy.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IReleasePolicy">
            <summary>
            Summary description for IReleasePolicy.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Releasers.LifecycledComponentsReleasePolicy">
            <summary>
            Only tracks components that have decommission steps
            registered
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Releasers.NoTrackingReleasePolicy">
            <summary>
            No tracking of component instances are made.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.DefaultDependencyResolver">
            <summary>
            Default implementation for <see cref="T:Castle.MicroKernel.IDependencyResolver"/>.
            This implementation is quite simple, but still should be useful
            for 99% of situations. 
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IDependencyResolver">
            <summary>
            Implementors should use a strategy to obtain 
            valid references to properties and/or services 
            requested in the dependency model.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ISubDependencyResolver">
            <summary>
            Implementors should use a strategy to obtain 
            valid references to properties and/or services 
            requested in the dependency model.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ISubDependencyResolver.Resolve(Castle.MicroKernel.CreationContext,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
            Should return an instance of a service or property values as
            specified by the dependency model instance. 
            It is also the responsability of <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
            to throw an exception in the case a non-optional dependency 
            could not be resolved.
            </summary>
            <param name="model"></param>
            <param name="dependency"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.ISubDependencyResolver.CanResolve(Castle.MicroKernel.CreationContext,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
            Returns true if the resolver is able to satisfy this dependency.
            </summary>
            <param name="model"></param>
            <param name="dependency"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IDependencyResolver.Initialize(Castle.MicroKernel.DependencyDelegate)">
            <summary>
            This method is called with a delegate for firing the
            IKernelEvents.DependencyResolving event.
            </summary>
            <param name="resolving">The delegate used to fire the event</param>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Resolve(Castle.MicroKernel.CreationContext,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
            Try to resolve the dependency by checking the parameters in 
            the model or checking the Kernel for the requested service.
            </summary>
            <param name="model"></param>
            <param name="dependency"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.CanResolve(Castle.MicroKernel.CreationContext,Castle.Core.ComponentModel,Castle.Core.DependencyModel)">
            <summary>
            Returns true if the resolver is able to satisfy this dependency.
            </summary>
            <param name="model"></param>
            <param name="dependency"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ExtractComponentKey(System.String,System.String)">
            <summary>
            Extracts the component name from the a ref strings which is
            ${something}
            </summary>
            <param name="keyValue"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.Resolvers.DefaultDependencyResolver.RebuildContextForParameter(Castle.MicroKernel.CreationContext,System.Type)">
            <summary>
            This method rebuild the context for the parameter type.
            Naive implementation.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Resolvers.DependencyResolverException">
            <summary>
            Summary description for DependencyResolverException.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Configuration.DefaultConfigurationStore">
            <summary>
            This implementation of <see cref="T:Castle.MicroKernel.IConfigurationStore"/>
            does not try to obtain an external configuration by any means.
            Its only purpose is to serve as a base class for subclasses
            that might obtain the configuration node from anywhere.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ISubSystem">
            <summary>
            A subsystem is used by the MicroKernel to deal 
            with a specific concern.  
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.ISubSystem.Init(Castle.MicroKernel.IKernel)">
            <summary>
            Initializes the subsystem
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.ISubSystem.Terminate">
            <summary>
            Should perform the termination
            of the subsystem instance.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IConfigurationStore">
            <summary>
            The contract used by the kernel to obtain
            external configuration for the components and
            facilities.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.AddFacilityConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a facility key
            </summary>
            <param name="key"></param>
            <param name="config"></param>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.AddComponentConfiguration(System.String,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Associates a configuration node with a component key
            </summary>
            <param name="key"></param>
            <param name="config"></param>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetFacilityConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified facility key. Should return null
            if no association exists.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetComponentConfiguration(System.String)">
            <summary>
            Returns the configuration node associated with 
            the specified component key. Should return null
            if no association exists.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetFacilities">
            <summary>
            Returns all configuration nodes for facilities
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetComponents">
            <summary>
            Returns all configuration nodes for components
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IConfigurationStore.GetResource(System.String,Castle.Core.Resource.IResource)">
            <summary>
            
            </summary>
            <param name="resourceUri"></param>
            <param name="resource"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.AbstractTypeConverter">
            <summary>
            Base implementation of <see cref="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter">
            <summary>
            Implements a conversion logic to a type of a
            set of types. 
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.CanHandleType(System.Type)">
            <summary>
            Returns true if this instance of <c>ITypeConverter</c>
            is able to handle the specified type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.CanHandleType(System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Returns true if this instance of <c>ITypeConverter</c>
            is able to handle the specified type with the specified 
            configuration
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.PerformConversion(System.String,System.Type)">
            <summary>
            Should perform the conversion from the
            string representation specified to the type
            specified.
            </summary>
            <param name="value"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.ITypeConverter.PerformConversion(Castle.Core.Configuration.IConfiguration,System.Type)">
            <summary>
            Should perform the conversion from the
            configuration node specified to the type
            specified.
            </summary>
            <param name="configuration"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.IKernelDependentConverter">
            <summary>
            Marker interface that signals that a converter
            depends on IKernel to be able to perform 
            the conversion.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.EnumConverter">
            <summary>
            Converts a string representation to an enum value
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.PrimitiveConverter">
            <summary>
            Implements all standard conversions.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.TypeNameConverter">
            <summary>
            Convert a type name to a Type instance.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.ConverterException">
            <summary>
            Summary description for ConverterException.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.DefaultConversionManager">
            <summary>
            Composition of all available conversion managers
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Conversion.IConversionManager">
            <summary>
            Establish a composition interface and a subsystem.
            Implementors should delegate the conversion to 
            a instance of a type converter.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Conversion.IConversionManager.Add(Castle.MicroKernel.SubSystems.Conversion.ITypeConverter)">
            <summary>
            Register a type converter instance.
            </summary>
            <param name="converter"></param>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.left">
            <summary>Node's left</summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.right">
            <summary>Node's right</summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.TreeNode.nextSibling">
            <summary>DA Linked List</summary>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.String)">
            <summary>
            Creates a ComponentName using a name pattern like
            "service:key=value,key2=value2"
            </summary>
            <param name="name">Complete name</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.String,System.String)">
            <summary>
            Creates a ComponentName with specified service and 
            properties.
            </summary>
            <param name="service">Service name</param>
            <param name="properties">Property list.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.Setup(System.String)">
            <summary>
            Parses the full name extracting the service and properties.
            </summary>
            <param name="name">Full name.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupService(System.String)">
            <summary>
            Sets up the service. Can be empty but can't be null.
            </summary>
            <param name="service"></param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupProperties(System.String)">
            <summary>
            Parses and validate a properties list string like 
            "key=value,key2=value2" and so on.
            </summary>
            <param name="properties">Property list.</param>
        </member>
        <member name="M:Castle.MicroKernel.SubSystems.Naming.ComponentName.SetupProperties(System.Collections.IDictionary)">
            <summary>
            Validates a properties Hashtable.
            </summary>
            <param name="properties">Property list.</param>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem">
            <summary>
            Default <see cref="T:Castle.MicroKernel.INamingSubSystem"/> implementation.
            Keeps services and key maps as simple hash tables. Does not
            support a query string.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.INamingSubSystem">
            <summary>
            Contract for SubSystem that wishes to keep and coordinate
            component registration.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.Register(System.String,Castle.MicroKernel.IHandler)">
            <summary>
            Implementors should register the key and service pointing 
            to the specified handler
            </summary>
            <param name="key"></param>
            <param name="handler"></param>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.UnRegister(System.String)">
            <summary>
            Unregister the handler by the given key
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.UnRegister(System.Type)">
            <summary>
            Unregister the handler by the given service
            </summary>
            <param name="service"></param>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.Contains(System.String)">
            <summary>
            Returns true if there is a component registered 
            for the specified key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.Contains(System.Type)">
            <summary>
            Returns true if there is a component registered 
            for the specified service
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandler(System.String)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandlers(System.String)">
            <summary>
            Returns an array of <see cref="T:Castle.MicroKernel.IHandler"/> that
            satisfies the specified query.
            </summary>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandler(System.Type)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified service.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandler(System.String,System.Type)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified key with the service type.
            <remarks>
            It is expected that this will be used mainly to resolve a generic service
            by its key.
            </remarks>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandlers(System.Type)">
            <summary>
            Returns an array of <see cref="T:Castle.MicroKernel.IHandler"/> associated with
            the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetHandlers">
            <summary>
            Returns all <see cref="T:Castle.MicroKernel.IHandler"/> registered.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetAssignableHandlers(System.Type)">
            <summary>
            Return <see cref="T:Castle.MicroKernel.IHandler"/>s where components are compatible
            with the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetKey2Handler">
            <summary>
            List of handler by key
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.INamingSubSystem.GetService2Handler">
            <summary>
            List of handler by service
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.INamingSubSystem.ComponentCount">
            <summary>
            Returns the number of components registered.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.INamingSubSystem.Item(System.Type)">
            <summary>
            Associates a <see cref="T:Castle.MicroKernel.IHandler"/> with 
            the specified service
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.INamingSubSystem.Item(System.String)">
            <summary>
            Associates a <see cref="T:Castle.MicroKernel.IHandler"/> with
            the specified key
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.key2Handler">
            <summary>
            Map(String, IHandler) to map component keys
            to <see cref="T:Castle.MicroKernel.IHandler"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystems.Naming.DefaultNamingSubSystem.service2Handler">
            <summary>
            Map(Type, IHandler) to map services 
            to <see cref="T:Castle.MicroKernel.IHandler"/>
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Naming.NamingPartsSubSystem">
            <summary>
            Alternative <see cref="T:Castle.MicroKernel.INamingSubSystem"/> implementation.
            Extends the default implementation replacing the 
            key support with a more complete ComponentName. Supports
            queries.
            </summary>
            <example>
            The user must register components using the following construction
            <code>
              service:properties
            </code>
            Where properties is a list of key value pairs (comma separated). Example:
            <code>
              protocol:secure=true,version=1.2
            </code>
            The user can then query for components using the same construction:
            <code>
              protocol:secure=true
            </code>
            Or to return all:
            <code>
              protocol:*
            </code>
            </example>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Resource.DefaultResourceSubSystem">
            <summary>
            Pendent
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystems.Resource.IResourceSubSystem">
            <summary>
            An implementation of <c>a</c> should 
            be able to return instances of <see cref="T:Castle.Core.Resource.IResource"/>
            for a given resource identifier.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.SubSystemConstants">
            <summary>
            Holds the keys used by Kernel to register/request 
            a subsystem.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ConfigurationStoreKey">
            <summary>
            Key used for the configuration store subsystem
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ConversionManagerKey">
            <summary>
            Key used for the conversion manager
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.NamingKey">
            <summary>
            Key used for the naming subsystem
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.SubSystemConstants.ResourceKey">
            <summary>
            Key used for the resource subsystem
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Util.ReferenceComparer">
            <summary>
            Compares if the reference of two objects are equals.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.Util.ReferenceExpressionUtil">
            <summary>
            Summary description for ReferenceExpressionUtil.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.DefaultKernel">
            <summary>
            Default implementation of <see cref="T:Castle.MicroKernel.IKernel"/>. 
            This implementation is complete and also support a kernel 
            hierarchy (sub containers).
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.KernelEventSupport">
            <summary>
            Summary description for KernelEventSupport.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.IKernelEvents">
            <summary>
            Summary description for IKernelEvents.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentRegistered">
            <summary>
            Event fired when a new component is registered 
            on the kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentUnregistered">
            <summary>
            Event fired when a component is removed from the kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentModelCreated">
            <summary>
            Event fired after the ComponentModel is created.
            Allows customizations that may affect the handler.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.AddedAsChildKernel">
            <summary>
            Event fired when the kernel was added as child of
            another kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.RemovedAsChildKernel">
            <summary>
            Event fired when the kernel was removed from being a child
            of another kernel.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentCreated">
            <summary>
            Event fired before the component is created.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.ComponentDestroyed">
            <summary>
            Event fired when a component instance destroyed.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.HandlerRegistered">
            <summary>
            Event fired when a new handler is registered 
            (it might be in a valid or waiting dependency state)
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.IKernelEvents.DependencyResolving">
            <summary>
            Event fired when a dependency is being resolved,
            it allows the dependency to be changed,
            but the client ComponentModel must not be altered.
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.HandlerRegistered">
            <summary>
            Pending
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentRegistered">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentUnregistered">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentCreated">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentDestroyed">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.AddedAsChildKernel">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.RemovedAsChildKernel">
            <summary>
            Pending
            </summary>
        </member>
        <member name="E:Castle.MicroKernel.KernelEventSupport.ComponentModelCreated">
            <summary>
            Pending
            </summary>
            <value></value>
        </member>
        <member name="T:Castle.MicroKernel.IKernel">
            <summary>
            The <c>IKernel</c> interface exposes all the functionality
            the MicroKernel implements.
            </summary>
            <remarks>
            It allows you to register components and
            request them by the key or the service they implemented.
            It also allow you to register facilities and subsystem, thus 
            augmenting the functionality exposed by the kernel alone to fits 
            your needs.
            <seealso cref="T:Castle.MicroKernel.IFacility"/>
            <seealso cref="T:Castle.MicroKernel.ISubSystem"/>
            </remarks>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type)">
            <summary>
            Adds a concrete class as a component
            </summary>
            <param name="key"></param>
            <param name="classType"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponent(System.String,System.Type,System.Type)">
            <summary>
            Adds a concrete class and an interface 
            as a component
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="classType"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentWithProperties(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
            Adds a concrete class as a component and specify the extended properties.
            Used by facilities, mostly.
            </summary>
            <param name="key"></param>
            <param name="classType"></param>
            <param name="extendedProperties"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentWithProperties(System.String,System.Type,System.Type,System.Collections.IDictionary)">
            <summary>
            Adds a concrete class and an interface 
            as a component and specify the extended properties.
            Used by facilities, mostly.
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="classType"></param>
            <param name="extendedProperties"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddCustomComponent(Castle.Core.ComponentModel)">
            <summary>
            Adds a custom made <see cref="T:Castle.Core.ComponentModel"/>.
            Used by facilities.
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentInstance(System.String,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="key"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddComponentInstance(System.String,System.Type,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RemoveComponent(System.String)">
            <summary>
            Returns true if the specified component was 
            found and could be removed (i.e. no other component depends on it)
            </summary>
            <param name="key">The component's key</param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.HasComponent(System.String)">
            <summary>
            Returns true if the specified key was registered
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.HasComponent(System.Type)">
            <summary>
            Returns true if the specified service was registered
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.Resolve(System.String,System.Type)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.ReleaseComponent(System.Object)">
            <summary>
            Releases a component instance. This allows
            the kernel to execute the proper decomission 
            lifecycles on the component instance.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.CreateComponentActivator(Castle.Core.ComponentModel)">
            <summary>
            Constructs an implementation of <see cref="T:Castle.MicroKernel.IComponentActivator"/>
            for the given <see cref="T:Castle.Core.ComponentModel"/>
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandler(System.String)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/>
            for the specified component key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandler(System.Type)">
            <summary>
            Returns the <see cref="T:Castle.MicroKernel.IHandler"/>
            for the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetHandlers(System.Type)">
            <summary>
            Return handlers for components that 
            implements the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetAssignableHandlers(System.Type)">
            <summary>
            Return handlers for components that 
            implements the specified service. 
            The check is made using IsAssignableFrom
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddFacility(System.String,Castle.MicroKernel.IFacility)">
            <summary>
            Adds a <see cref="T:Castle.MicroKernel.IFacility"/> to the kernel.
            </summary>
            <param name="key"></param>
            <param name="facility"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetFacilities">
            <summary>
            Returns the facilities registered on the kernel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddSubSystem(System.String,Castle.MicroKernel.ISubSystem)">
            <summary>
            Adds (or replaces) an <see cref="T:Castle.MicroKernel.ISubSystem"/>
            </summary>
            <param name="key"></param>
            <param name="subsystem"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.GetSubSystem(System.String)">
            <summary>
            Returns an implementation of <see cref="T:Castle.MicroKernel.ISubSystem"/>
            for the specified key. 
            <seealso cref="T:Castle.MicroKernel.SubSystemConstants"/>
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.AddChildKernel(Castle.MicroKernel.IKernel)">
            <summary>
            Support for kernel hierarchy
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:Castle.MicroKernel.IKernel.RemoveChildKernel(Castle.MicroKernel.IKernel)">
            <summary>
            Remove child kernel
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Item(System.String)">
            <summary>
            Returns the component instance by the key
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Item(System.Type)">
            <summary>
            Returns the component instance by the Type
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ComponentModelBuilder">
            <summary>
            Returns the implementation of <see cref="T:Castle.MicroKernel.IComponentModelBuilder"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.HandlerFactory">
            <summary>
            Returns the implementation of <see cref="T:Castle.MicroKernel.IHandlerFactory"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ConfigurationStore">
            <summary>
            Gets or sets the implementation of <see cref="T:Castle.MicroKernel.IConfigurationStore"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ReleasePolicy">
            <summary>
            Returns the implementation for <see cref="T:Castle.MicroKernel.IReleasePolicy"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Resolver">
            <summary>
            Returns the implementation for <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.ProxyFactory">
            <summary>
            Gets or sets the implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            allowing different strategies for proxy creation.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.Parent">
            <summary>
            Returns the parent kernel
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.IKernel.GraphNodes">
            <summary>
            Graph of components and iteractions.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.parentKernel">
            <summary>
            The parent kernel, if exists.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.handlerFactory">
            <summary>
            The implementation of <see cref="T:Castle.MicroKernel.IHandlerFactory"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.modelBuilder">
            <summary>
            The implementation of <see cref="T:Castle.MicroKernel.IComponentModelBuilder"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.resolver">
            <summary>
            The dependency resolver.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.releaserPolicy">
            <summary>
            Implements a policy to control component's
            disposal that the usef forgot.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.proxyFactory">
            <summary>
            Holds the implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.facilities">
            <summary>
            List of <see cref="T:Castle.MicroKernel.IFacility"/> registered.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.subsystems">
            <summary>
            Map of subsystems registered.
            </summary>
        </member>
        <member name="F:Castle.MicroKernel.DefaultKernel.childKernels">
            <summary>
            List of sub containers.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor">
            <summary>
            Constructs a DefaultKernel with no component
            proxy support.
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor(Castle.MicroKernel.IDependencyResolver,Castle.MicroKernel.IProxyFactory)">
            <summary>
            Constructs a DefaultKernel with the specified
            implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/> and <see cref="T:Castle.MicroKernel.IDependencyResolver"/>
            </summary>
            <param name="resolver"></param>
            <param name="proxyFactory"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.#ctor(Castle.MicroKernel.IProxyFactory)">
            <summary>
            Constructs a DefaultKernel with the specified
            implementation of <see cref="T:Castle.MicroKernel.IProxyFactory"/>
            </summary>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentWithProperties(System.String,System.Type,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="classType"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentWithProperties(System.String,System.Type,System.Type,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="classType"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddCustomComponent(Castle.Core.ComponentModel)">
            <summary>
            
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentInstance(System.String,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="key"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.AddComponentInstance(System.String,System.Type,System.Object)">
            <summary>
            Used mostly by facilities. Adds an instance
            to be used as a component.
            </summary>
            <param name="key"></param>
            <param name="serviceType"></param>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Resolve(System.String,System.Type)">
            <summary>
            Returns a component instance by the key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetHandlers(System.Type)">
            <summary>
            Return handlers for components that 
            implements the specified service.
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetAssignableHandlers(System.Type)">
            <summary>
            Return handlers for components that 
            implements the specified service. 
            The check is made using IsAssignableFrom
            </summary>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.GetFacilities">
            <summary>
            Returns the facilities registered on the kernel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.MicroKernel.DefaultKernel.Dispose">
            <summary>
            Starts the process of component disposal.
            </summary>
        </member>
        <member name="P:Castle.MicroKernel.DefaultKernel.GraphNodes">
            <summary>
            Graph of components and iteractions.
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.ComponentDataDelegate">
            <summary>
            Represents a delegate which holds basic information about a component.
            </summary>
            <param name="key">Key which identifies the component</param>
            <param name="handler">handler that holds this component and is capable of 
            creating an instance of it.
            </param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentInstanceDelegate">
            <summary>
            Represents a delegate which holds basic information about a component
            and its instance.
            </summary>
            <param name="model">Component meta information</param>
            <param name="instance">Component instance</param>
        </member>
        <member name="T:Castle.MicroKernel.ComponentModelDelegate">
            <summary>
            Represents a delegate which holds the information about the 
            component
            </summary>
        </member>
        <member name="T:Castle.MicroKernel.HandlerDelegate">
            <summary>
            Represents a delegate which holds a handler
            </summary>
            <param name="handler">handler that holds a component and is capable of 
            creating an instance of it.
            </param>
        </member>
        <member name="T:Castle.MicroKernel.DependencyDelegate">
            <summary>
            Represents a delegate which holds dependency
            resolving information.
            </summary>
        </member>
    </members>
</doc>
